package main

type XmlType struct {
	NameType, XMLName, XMLNameUpper, XMLSpace, Structs, Filename string
}

const codeTemplate = `
package main

//Code generated by chidley https://github.com/gnewton/chidley

import (
	"bufio"
	"compress/bzip2"
	"compress/gzip"
	"encoding/json"
	"encoding/xml"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

{{.Structs}}

const (
	JsonOut = iota
	XmlOut
)

var toJson bool = false
var toXml bool = false
var musage bool = false

var filename = "{{.Filename}}"

func init() {
	flag.BoolVar(&toJson, "J", toJson, "Convert to JSON")
	flag.BoolVar(&toXml, "X", toXml, "Convert to XML")
	flag.BoolVar(&musage, "h", musage, "Usage")
	flag.StringVar(&filename, "f", filename, "XML file or URL to read in")
}

var out int = JsonOut

func main() {
	flag.Parse()

	if musage {
		flag.Usage()
		return
	}
	if toXml {
		out = XmlOut
		toJson = false
	} else {
		if toJson {
			out = JsonOut
			toXml = false
		} else {
			flag.Usage()
			return
		}

	}

	reader, xmlFile, err := genericReader(filename)
	if err != nil {
		log.Fatal(err)
		return
	}
	defer xmlFile.Close()
	decoder := xml.NewDecoder(reader)
	feedCount := 0
	for {
		token, _ := decoder.Token()
		if token == nil {
			break
		}
		switch se := token.(type) {
		case xml.StartElement:
			feedCount = handleFeed(se, decoder, feedCount)
		}
	}
	log.Print("feed count=", feedCount)
}

func handleFeed(se xml.StartElement, decoder *xml.Decoder, count int) int {
	if se.Name.Local == "{{.XMLName}}" && se.Name.Space == "{{.XMLSpace}}" {
		var item {{.NameType}}
		decoder.DecodeElement(&item, &se)
		switch out {
		case JsonOut:
			writeJson(item)
		case XmlOut:
			writeXml(item)
		}
		return count + 1
	} else {
		return count
	}
}

func writeJson(item interface{}) {
	b, err := json.MarshalIndent(item, "", " ")
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(b))
}

func writeXml(item interface{}) {
	output, err := xml.MarshalIndent(item, "  ", "    ")
	if err != nil {
		fmt.Printf("error: %v\n", err)
	}
	os.Stdout.Write(output)
}

func genericReader(filename string) (io.Reader, *os.File, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, nil, err
	}
	if strings.HasSuffix(filename, "bz2") {
		return bufio.NewReader(bzip2.NewReader(bufio.NewReader(file))), file, err
	}

	if strings.HasSuffix(filename, "gz") {
		reader, err := gzip.NewReader(bufio.NewReader(file))
		if err != nil {
			return nil, nil, err
		}
		return bufio.NewReader(reader), file, err
	}
	return bufio.NewReader(file), file, err
}

`
